/*
Copyright Â© 2021 JcdeA <jcde@jcde.xyz>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
	"crypto/ed25519"
	"encoding/pem"
	"errors"
	"fmt"
	"log"

	"net"

	"os"
	"strings"
	"time"

	"github.com/jcdea/aarch64-client-go"
	"github.com/jcdea/edkey"
	"github.com/jcdea/fhctl/check"
	"github.com/jcdea/fhctl/choose"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"golang.org/x/crypto/ssh"
	"golang.org/x/term"
)

// sshCmd represents the ssh command
var sshCmd = &cobra.Command{
	Use:   "ssh",
	Short: "SSH into a vm",

	Run: func(cmd *cobra.Command, args []string) {
		// We already check if user is signed in at GetProjects

		vm, err := choose.ChooseVM(args)
		check.CheckErr(err, "")
		sshVM(vm)

	},
}

func init() {
	rootCmd.AddCommand(sshCmd)
}

// if err != nil {
// 	if err.Error() != "exit status 130" {
// 		check.CheckErr(err, "")
// 	}
// }

// SSH into VM
func sshVM(vm aarch64.VM) error {

	var session *ssh.Session

	privKey, pubKeyString, err := initSSHKeys()
	check.CheckErr(err, "")
	signer, err := ssh.NewSignerFromKey(privKey)

	check.CheckErr(err, "Failed creating signer from privkey")

	if !ipv6able() {
		var client *ssh.Client

		auth := []ssh.AuthMethod{
			ssh.PublicKeys(signer),
		}
		client, err = jumpSSH(auth, vm)
		if err != nil {
			println("ssh keys not copied yet; copying now.")
			copySSHKeys(vm, pubKeyString)

			client, err = jumpSSH(auth, vm)
			check.CheckErr(err, "")

			session, err = client.NewSession()
			check.CheckErr(err, "")
			defer session.Close()

		} else {
			session, err = client.NewSession()
			check.CheckErr(err, "")
			defer session.Close()

		}
		setupSession(session)

	}
	auth := []ssh.AuthMethod{
		ssh.PublicKeys(signer),
	}
	sshConfig := &ssh.ClientConfig{
		User: "root",
		Auth: auth,
		HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {
			// TODO: fix this thing to properly check host
			if askIsHostTrusted(hostname, key) {
				return nil
			} else {
				return errors.New("host is not trusted")
			}
		},
		Timeout: time.Second * 30,
	}
	client, err := ssh.Dial("tcp6", fmt.Sprintf("[%v]:22", strings.Split(vm.Address, "/")[0]), sshConfig)
	check.CheckErr(err, "failed to dial host")

	session, err = client.NewSession()
	check.CheckErr(err, "")
	defer session.Close()
	setupSession(session)

	return nil

}

func setupSession(session *ssh.Session) error {
	session.Stderr = os.Stderr
	session.Stdin = os.Stdin
	session.Stdout = os.Stdout

	fd := int(os.Stdin.Fd())
	state, err := term.MakeRaw(fd)
	if err != nil {
		return fmt.Errorf("terminal make raw: %s", err)
	}
	defer term.Restore(fd, state)

	w, h, err := term.GetSize(fd)
	if err != nil {
		return fmt.Errorf("terminal get size: %s", err)
	}

	modes := ssh.TerminalModes{
		ssh.ECHO:          1,
		ssh.TTY_OP_ISPEED: 14400,
		ssh.TTY_OP_OSPEED: 14400,
	}

	term := os.Getenv("TERM")
	if term == "" {
		term = "xterm-256color"
	}
	if err := session.RequestPty(term, h, w, modes); err != nil {
		return fmt.Errorf("session xterm: %s", err)
	}

	// Forward user commands to the remote shell
	if err := session.Shell(); err != nil {

		check.CheckErr(err, "")
		log.Fatalf("failed to start shell: %s", err)
	}
	if err := session.Wait(); err != nil {
		if err.Error() == "Process exited with status 127" {
			os.Exit(0)
		} else {
			panic(err)
		}
	}
	return nil
}

func copySSHKeys(vm aarch64.VM, authorizedKey string) (err error) {
	var auth []ssh.AuthMethod

	check.CheckErr(err, "")
	auth = []ssh.AuthMethod{
		ssh.Password(vm.Password),
	}
	sshClient, err := jumpSSH(auth, vm)
	if err != nil {
		return err
	}

	session, err := sshClient.NewSession()
	if err != nil {
		return err
	}
	defer session.Close()

	hostname, err := os.Hostname()
	if err != nil {
		hostname = "unknown host"
	} else {
		hostname = fmt.Sprintf("host %v", hostname)
	}
	println("copying ssh keys..")
	err = session.Run(fmt.Sprintf("echo \"%v %v %v\" >> ~/.ssh/authorized_keys", strings.TrimRight(authorizedKey, "\n"), "Generated by fhctl for ", hostname))

	check.CheckErr(err, "")
	println("copied ssh keys!")
	return nil
}

func jumpSSH(auth []ssh.AuthMethod, vm aarch64.VM) (client *ssh.Client, err error) {
	jumpConfig := &ssh.ClientConfig{
		User: "jump",
		Auth: auth,
		HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {
			// TODO: fix this thing to properly check host
			if askIsHostTrusted(hostname, key) {
				return nil
			} else {
				return errors.New("host is not trusted")
			}
		},
		Timeout: time.Second * 10,
	}

	bClient, err := ssh.Dial("tcp", fmt.Sprintf("%v%v.infra.aarch64.com:22", vm.PoP, vm.Host), jumpConfig)
	if err != nil {
		log.Fatal(err)
	}

	addr := strings.Split(vm.Address, "/")[0]

	// Dial a connection to the service host, from the jump server
	conn, err := bClient.Dial("tcp6", fmt.Sprintf("[%v]:22", addr))
	if err != nil {
		log.Fatal(err)
	}

	finalConfig := &ssh.ClientConfig{
		User: "root",
		Auth: auth,
		HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {
			// TODO: fix this thing to properly check host
			if askIsHostTrusted(hostname, key) {
				return nil
			} else {
				return errors.New("host is not trusted")
			}
		},
		Timeout: time.Second * 30,
	}
	ncc, chans, reqs, err := ssh.NewClientConn(conn, addr, finalConfig)
	if err != nil {
		return nil, err
	}

	return ssh.NewClient(ncc, chans, reqs), nil
}

// Does the client support ipv6?
func ipv6able() bool {
	_, err := net.DialTimeout("tcp", "[2606:4700:4700::1111]:53", 1*time.Second)
	if err != nil {
		println(err.Error())
		println("ipv6 not available")
		return false
	}
	return true
}

func initSSHKeys() (privateKey interface{}, authorizedKey string, err error) {
	privKey := viper.GetString("ssh.privKey")
	pubKey := viper.GetString("ssh.pubKey")

	if privKey == "" || pubKey == "" {
		// Generate a new private/public keypair for OpenSSH
		pubKey, privKey, _ := ed25519.GenerateKey(nil)
		publicKey, _ := ssh.NewPublicKey(pubKey)

		pemBLock := &pem.Block{
			Type:  "OPENSSH PRIVATE KEY",
			Bytes: edkey.MarshalED25519PrivateKey(privKey),
		}

		pemPrivKey := string(pem.EncodeToMemory(pemBLock))
		pubKey = ssh.MarshalAuthorizedKey(publicKey)

		viper.Set("ssh.privKey", pemPrivKey)
		viper.Set("ssh.pubKey", string(pubKey))
		viper.WriteConfig()

		return privKey, string(pubKey), nil
	} else {

		parsed, err := ssh.ParseRawPrivateKey([]byte(fmt.Sprintln(privKey)))
		check.CheckErr(err, "Failed to parse private key")
		return parsed, pubKey, nil
	}
}
func askIsHostTrusted(host string, key ssh.PublicKey) bool {

	// reader := bufio.NewReader(os.Stdin)

	// fmt.Printf("Unknown Host: %s \nFingerprint: %s \n", host, ssh.FingerprintSHA256(key))
	// fmt.Print("Would you like to add it? type yes or no: ")

	// a, err := reader.ReadString('\n')

	// if err != nil {
	// 	log.Fatal(err)
	// }

	// return strings.ToLower(strings.TrimSpace(a)) == "yes"
	return true
}
